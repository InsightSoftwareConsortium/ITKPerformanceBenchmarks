%
% Complete documentation on the extended LaTeX markup used for Insight
% documentation is available in ``Documenting Insight'', which is part
% of the standard documentation for Insight.  It may be found online
% at:
%
%     http://www.itk.org/

\documentclass{InsightArticle}

\usepackage[dvips]{graphicx}
\usepackage{color}
\usepackage{minted}
\definecolor{ltgray}{rgb}{0.93,0.93,0.93}
\usemintedstyle{emacs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  hyperref should be the last package to be loaded.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[dvips,
bookmarks,
bookmarksopen,
backref,
colorlinks,linkcolor={blue},citecolor={blue},urlcolor={blue},
]{hyperref}


%  This is a template for Papers to the Insight Journal.
%  It is comparable to a technical report format.

% The title should be descriptive enough for people to be able to find
% the relevant document.
\title{Performance Benchmarking the Insight Toolkit}

%
% NOTE: This is the last number of the "handle" URL that
% The Insight Journal assigns to your paper as part of the
% submission process. Please replace the number "1338" with
% the actual handle number that you get assigned.
%
\newcommand{\IJhandlerIDnumber}{1338}

% Increment the release number whenever significant changes are made.
% The author and/or editor can define 'significant' however they like.
\release{1.0.0}

% At minimum, give your name and an email address.  You can include a
% snail-mail address if you like.
\author{Matthew McCormick$^{1}$, Hyun Jae Kang$^{1}$, and Stephen Aylward$^{1}$}
\authoraddress{$^{1}$Kitware, Inc, Carrboro, NC}

\begin{document}

%
% Add hyperlink to the web location and license of the paper.
% The argument of this command is the handler identifier given
% by the Insight Journal to this paper.
%
\IJhandlefooter{\IJhandlerIDnumber}


\ifpdf
\else
   %
   % Commands for including Graphics when using latex
   %
   \DeclareGraphicsExtensions{.eps,.jpg,.gif,.tiff,.bmp,.png}
   \DeclareGraphicsRule{.jpg}{eps}{.jpg.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.gif}{eps}{.gif.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.tiff}{eps}{.tiff.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.bmp}{eps}{.bmp.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.png}{eps}{.png.bb}{`convert #1 eps:-}
\fi


\maketitle


\ifhtml
\chapter*{Front Matter\label{front}}
\fi

\begin{abstract} \noindent This document describes a module for the Insight
Toolkit (ITK) \url{www.itk.org} to assist in performance benchmarking and a
suite of benchmarks for the toolkit. These resources provide metrics to
quantify software computational performance. This is a pre-requisite to
improve performance either through algorithmic advancements or better
utilization of hardware resources.

Computional performance is quantified by reducing factors that confound timing
measurements and by estimating measurement variance. New classes are presented
that increase operating system process priority to minimize the impact of
other processes running on the system. System hardware characteristics are
extracted and displayed. The influence of hard disk input/output on runtime
measurements is removed in the suite of benchmarks. Additionally, the number
of threads used by each benchmark can be specified. These benchmarks consist
of common analysis pipelines and run on 3D magnetic resonance brain image data
so realistic performance is quantified. Benchmarks can be executed with
multiple iterations, and timing statistics are recorded in tab separated value
(.tsv) files, which are easily stored or processed for further analysis and
visualization.

This paper is accompanied with the source code, input data, parameters and
output data that the authors used for validating the algorithm described in
this paper. This adheres to the fundamental principle that scientific
publications must facilitate reproducibility of the reported results.

\end{abstract}

\IJhandlenote{\IJhandlerIDnumber}

\tableofcontents

\section{Introduction}

To make quantifiable improvements in computational software performance, the
performance must be measureable. This article describes performance
measurement tools in the Insight Toolkit (ITK,\url{www.itk.org}), and how they
are applied to benchmark scientific image analysis code. In addition, the
article also describes a suite of example benchmarks that quantify ITK image
processing pipeline performance. Informative performance metrics require
consideration of the behavior to be optimized and factors that influence
measurement of the desired behavior

The behavior this article focuses on is the time required to execute software
image analysis pipelines on realistic image datasets. Full pipelines are
benchmarked since this is what impacts the experience of software users. Hard
disk input/output (I/O) influence is removed from timings because it may not
be present in applications in the same form as the benchmarks. Additionaly,
data I/O is highly dependent on the I/O hardware and is relatively software
independent. The data processed is based on a 3D magnetic resonance
BrainWeb\cite{BrainWeb1,BrainWeb2} image, which has realistic size and
content. Benchmarks inputs and operations are also designed for a target runtime of
approximately 1-2 seconds for a single iteration and approximately 5-10
seconds for multiple iterations on current systems. These durations are
intended to be long enough for memory access and processing times to reach a
steady state yet short enough for the benchmark suite to be executed in a
reasonable amount of time.

The benchmarks attempt to minimize the influence of the operating system and
hardware and other processing running on the system. The type of operating
system and hardware used is recorded and the number of hardware threads used
is governable in each benchmark so performance can be normalized and optimized
for processor and memory type and thread-based parallelism. Operating system
process priority is increased on the benchmark process to reduce the impact of
other processes running on the system. A high precision real-time clock is
used to measure timings.  Timing variations are recorded in statistics
generated by running the benchmark pipelines multiple times.

The code for the ITK module, example benchmarks, and results presented in this
article can be found at
\url{https://github.com/InsightSoftwareConsortium/ITKPerformanceBenchmarking}.
The code must be built against ITK 4.11.0 or newer, which includes improvements to
the resource recording classes.

The sections that follow describe in further detail first the classes in the
\code{PerformanceBenchmarking} ITK module and how they are used, then the
example benchmark suite.

\section{PerformanceBenchmarking Module}

The \code{PerformanceBenchmarking} module currently contains classes that
extend the \doxygen{RealTimeClock}, \doxygen{RealTimeProbe}, and
\doxygen{RealTimeProbesCollector} classes by also increasing the current
process's operating system priority. The \doxygen{HighPriorityRealTimeClock}
class uses operating system specific calls to increase the current process's
priority in its constructor and return it to its previous value in its
destructor. The \doxygen{HighPriorityRealTimeProbe} and
\doxygen{HighPriorityRealTimeProbesCollector} use a
\doxygen{HighPriorityRealTimeClock}.

A higher process priority increases the amount of computing resources allotted
to the benchmark process relative to the other processes running on the
system.

\begin{figure}
\center
\includegraphics[width=0.8\textwidth]{FigureProcessorPriority/ProcessorPriority.eps}
\itkcaption[Processor Priority Influence]{The impact of an increased process
priority when a parallel build of ITK is running in the background and when
only a few system processes are running. Times are given with mean +/- two
standard errors. In general, benchmark runtimes and their variability is more
closer to low load system results when the process priority is increased.}
\label{fig:ProcessorPriority}
\end{figure}

Figure~\ref{fig:ProcessorPriority} illustrates the difference in benchmarks
timings when an ITK build is running in the background on the system and when
only standard background processes are running. When only standard background
processes are running, the timing results are similar regardless of the
process priority. However, an elevated process priority reduce the increased
mean time and variance that occurs with a high system background load.  The
parallel builds were executed with the \code{-j20} parallelism flag on a
system whose characteristics are given below.

\begin{verbatim}
System:              meyer
Processor:           Unknown P6 family
    Cache:           6144
    Clock:           3250.41
    Physical CPUs:   1
    Logical CPUs:    8
    Virtual Memory:  Total: 19322           Available: 19321
    Physical Memory: Total: 16003           Available: 7149
OSName:              Linux
    Release:         3.16.0-4-amd64
    Version:         #1 SMP Debian 3.16.7-ckt25-2 (2016-04-08)
    Platform:        x86_64
    Operating System is 64 bit
ITK Version: 4.11.0
\end{verbatim}

Example usage of the high priority timing classes is shown in the code below,
taken from the Median example benchmark. Note that this may effect other high
priority applications running on the system like graphical user interfaces,
network connections, etc. On Unix-like system, the process should be run as the \code{root} user so it has adequate permission to elevate the priority; running as a normal user will not result in a higher than normal process priority.
\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cpp}
#include "itkHighPriorityRealTimeProbesCollector.h"

[...]

ImageType::Pointer inputImage = reader->GetOutput();
inputImage->DisconnectPipeline();

itk::HighPriorityRealTimeProbesCollector collector;
for( int ii = 0; ii < iterations; ++ii )
  {
  inputImage->Modified();
  collector.Start("Median");
  filter->UpdateLargestPossibleRegion();
  collector.Stop("Median");
  }
bool printSystemInfo = true;
bool printReportHead = true;
bool useTabs = false;
collector.Report( std::cout, printSystemInfo, printReportHead, useTabs );

std::ofstream timingsFile( timingsFileName, std::ios::out );
printSystemInfo = false;
useTabs = true;
collector.ExpandedReport( timingsFile, printSystemInfo, printReportHead, useTabs );
\end{minted}

\section{Benchmark Suite}

\subsection{The Benchmarks}

- analysis pipelines

The purpose of these benchmarks is to 
To apply these benchmarks for comparisons of different algorithmic
approaches to the same analytic objective, greater care should be given to ensure the parameters of
the pipelines are optimal. Additionally, attention must the results from competing algorithms are
similar.

- input data
-- graph
- outputs
-- text output
-- .tsv example

\subsection{Removal of Disk I/O}
- graph

\subsection{How to Build and Run}
- requires ITK 4.11.0 or newer
- build superbuild
- run ctest
- specify iterations and threads



Using filters from the Insight Toolkit, we develop an algorithm for detecting
and tracking thje movement of solar spots. As it is widely known, celestial
objects such as the sun are ethereal and perfect, and therefore can not harbor
artifacts such as spots. However, observations performed with our open source
telescope have revealed the presence of such spots. The spots seems to continuously change positions on the solar surface.

Automatic detection and tracking of the solar spot movements are of fundamental
importance for allowing the authors to dedicate more time to perfectioning
optical instruments and less time to the supervised acquisition of reliable
data.

The reader should be warned that direct observation of the sun without proper
equipment may result in personal injury, loss of vision and burned brains.

\section{Principles of Solar Spot Detection}

Solar spots can be classified as the darkest objects present on an image of the
solar surface. Algorithms such as watersheds, statistical classification and
mathematical morphology are suitable for automatically detecting these features
in images of the solar surface.


\section{Why Image Processing Papers must include Source Code, Images and Parameters }

Modern Image Processing is most of the time performed with computers. An
attempt to replicate the results of an algorithm described in a paper entails
to reimplement the algorithm into source code. This task is far from trivial
and consumes months of work. The final result can not be guarranted to be
equivalent to the actual code that was used for testing the algorithm when the
paper was written, and therefore it cannot be considered a baseline for
comparing the algoritm with other algorithms availble to the reader.

Papers to the Insight Journal are written in the spirit of facilitating and
encouraging readers to perform replication of work. In this sense, the Insight
Journal is compliant with essential concepts of the scientific method.

Since the code is included with the paper, less time has to be spent in
describing the code, and more time can be used for describing how to use the
algorithm in particular types of images.

For questions on the basis of the scientific method the reader is refered to
\cite{Popper2002,Popper1971}.



\section{Pointing to other material}

The format of this LaTeX file, allows authors to include code snippets, like
the following

\small
\begin{verbatim}
typedef itk::Image< unsigned char, 3 > ImageType;

ImageType::Pointer image = ImageType::New();
\end{verbatim}
\normalsize

and to cite the online documentation of the Insitght Toolkit, for example, the
link to the doxygen documentation of the ImageToImageFilter

\doxygen{ImageToImageFilter}

LaTeX macros are also available for typesetting code in familiar courier fonts.
Like the following method of an ITK class.

\code{SetNumberOfIterations()}



% The preceding sections will have been written in a gentler,
% introductory style.  You may also wish to include a reference
% section, documenting all the functions/exceptions/constants.
% Often, these will be placed in separate files and input like this:



\appendix

\section{This is an Appendix}

To create an appendix in a Insight HOWTO document, use markup like
this:

\begin{verbatim}
\appendix

\section{This is an Appendix}

To create an appendix in a Insight HOWTO document, ....


\section{This is another}

Just add another \section{}, but don't say \appendix again.
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Example on how to insert an equation.
%  Never forget to put an equation in your paper.
%  They make them look professional and impress the reviewers.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


To support shape-guidance, the generic level set equation
(Eqn(~\ref{eqn:ShapeInfluenceTerm})) is extended to incorporate a shape guidance
term:

\begin{equation}
\label{eqn:ShapeInfluenceTerm}
\xi \left(\psi^{*}(\mathbf{x}) - \psi(\mathbf{x})\right)
\end{equation}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Insert the bibliography using BibTeX
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{plain}
\bibliography{InsightJournal}


\end{document}


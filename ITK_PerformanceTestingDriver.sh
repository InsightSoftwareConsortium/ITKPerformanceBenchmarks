#!/bin/bash
# \author Hans J. Johnson
#

#-------------------------------------------------------------------------------------------------------------------
## https://stackoverflow.com/questions/6481005/how-to-obtain-the-number-of-cpus-cores-in-linux-from-the-command-line
# macOS:           Use `sysctl -n hw.*cpu_max`, which returns the values of
#                  interest directly.
#                  CAVEAT: Using the "_max" key suffixes means that the *maximum*
#                          available number of CPUs is reported, whereas the
#                          current power-management mode could make *fewer* CPUs
#                          available; dropping the "_max" suffix would report the
#                          number of *currently* available ones; see [1] below.
#
# Linux:           Parse output from `lscpu -p`, where each output line represents
#                  a distinct (logical) CPU.
#                  Note: Newer versions of `lscpu` support more flexible output
#                        formats, but we stick with the parseable legacy format
#                        generated by `-p` to support older distros, too.
#                        `-p` reports *online* CPUs only - i.e., on hot-pluggable
#                        systems, currently disabled (offline) CPUs are NOT
#                        reported.

# Number of LOGICAL CPUs (includes those reported by hyper-threading cores)
  # Linux: Simply count the number of (non-comment) output lines from `lscpu -p`,
  # which tells us the number of *logical* CPUs.
logicalCpuCount=$([[ $(uname) = 'Darwin' ]] &&
                       sysctl -n hw.logicalcpu_max ||
                       lscpu -p | egrep -v '^#' | wc -l)

# Number of PHYSICAL CPUs (cores).
  # Linux: The 2nd column contains the core ID, with each core ID having 1 or
  #        - in the case of hyperthreading - more logical CPUs.
  #        Counting the *unique* cores across lines tells us the
  #        number of *physical* CPUs (cores).
physicalCpuCount=$([[ $(uname) = 'Darwin' ]] &&
                       sysctl -n hw.physicalcpu_max ||
                       lscpu -p | egrep -v '^#' | sort -u -t, -k 2,4 | wc -l)
#-------------------------------------------------------------------------------------------------------------------

if [[ 0 -eq 1 ]] ;then
#  Get a long list of hashes to consider
#  git log v4.12.0..origin/master --reverse --merges --format="%H %ci %aN %s"
#
export CC=$(which gcc)
export CXX=$(which g++)
cd  /home/johnsonhj/Dashboard/src/ITK && for hash_to_test in $( git log v4.12.0..origin/master --reverse --merges --format="%H" ); do
   /home/johnsonhj/Dashboard/src/ITKPerformanceBenchmarking/ITK_PerformanceTestingDriver.sh \
        --src /home/johnsonhj/Dashboard/src/ITK \
        --bld /home/johnsonhj/Dashboard/src/ITK-gcc5 \
        --perf-src /home/johnsonhj/Dashboard/src/ITKPerformanceBenchmarking \
        --perf-bld /home/johnsonhj/Dashboard/src/ITKPB-bld \
        --git-tag ${hash_to_test}
done

fi


function usage() {
# -s | --src The ITK src directory
# -b | --bld The ITK build directory
# -p | --perf-src The ITKPerformanceBenchmark srcdir
# -t | --perf-bld The ITKPerformanceBenchmark testing (aka build) dir
# -g | --git-tag The git tag to generate performance information for
   echo "Usage: $0 [-s|--src ITK_SRC] [-b|--bld ITK_BLD] [-g|--git-tag GIT_TAG] \\" 1>&2
   echo "          [-p|--perf-src PERF_SRC] [-t|--perf-bld PERF_BLD] [-g|--git-tag GIT_TAG] " 1>&2
}

OPTS=$(getopt -o s:b:p:t:g: --long src:,bld:,perf-src:,perf-bld:,git-tag:  -n '${0}' -- "$@")
if [[ $? -ne 0 ]]; then
   echo "Failed parsing options." 1>&2
   usage
fi

echo "$OPTS"
eval set -- "$OPTS"
while true; do
  case "$1" in
    -s | --src ) ITK_SRC="$2"; shift;shift ;;
    -b | --bld )    ITK_BLD="$2"; shift;shift ;;
    -p | --perf-src ) PERF_SRC="$2"; shift;shift ;;
    -t | --perf-bld ) PERF_BLD="$2"; shift; shift ;;
    -g | --git-tag ) ITK_GIT_TAG="$2"; shift; shift ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

echo "ITK_SRC: ${ITK_SRC}"
echo "ITK_BLD: ${ITK_BLD}"
echo "PERF_SRC: ${PERF_SRC}"
echo "PERF_BLD: ${PERF_BLD}"
echo "ITK_GIT_TAG: ${ITK_GIT_TAG}"

## START REAL PROCESSING

#########################
## Get the requested tag
##
pushd ${ITK_SRC}
git stash
git checkout ${ITK_GIT_TAG}  ##     || echo "FAILED TO checkout ITK ${ITK_GIT_TAG}" &&  exit -1
git reset --hard ${ITK_GIT_TAG}
echo "Finished checking out ITK"
popd

#########################
## Generate an environmental variable to supplement report generation
##
pushd ${ITK_SRC}
export GIT_CONFIG_SHA1="$(git rev-parse HEAD)"
export GIT_CONFIG_DATE="$(git show -s --format=%ci HEAD)"
export GIT_LOCAL_MODIFICATIONS="$(git  diff --shortstat HEAD)"
export ITKPERFORMANCEBENCHMARK_AUX_JSON="
{
\"ITK_MANUAL_BUILD_INFO\": {
 \"GIT_CONFIG_DATE\": \"${GIT_CONFIG_DATE}\",
 \"GIT_CONFIG_SHA1\": \"${GIT_CONFIG_SHA1}\",
 \"GIT_LOCAL_MODIFICATIONS\": \"${GIT_LOCAL_MODIFICATIONS}\"
}
}
"
echo "Finished compiling config info."
popd

#########################
## Build ITK for Performance testing
##
pushd ${ITK_BLD}
echo "Building ITK..."
cmake -DCMAKE_BUILD_TYPE:STRING=Release \
      -DCMAKE_CXX_STANDARD:STRING=11 \
      -DBUILD_TESTING:BOOL=OFF \
      -DBUILD_EXAMPLES:BOOL=OFF \
      \
      ${ITK_SRC} > ITK_CONFIG_logger 2>&1
make -j ${logicalCpuCount} > ITK_BUILD_logger 2>&1 # || echo "FAILED TO BUILD ITK: ${ITK_GIT_TAG}" && exit -1
echo "Finished bulding ITK"
popd

#########################
## Build ITKPerformanceBenchmark
##
pushd ${PERF_SRC}
git checkout ImproveReportingDiagnostics #  || echo "FAILED TO CHECKOUT ITKPerformanceBenchmarking" && exit -1
echo "Finished checking out ITKPerformanceBenchmark"
popd
echo "Building and testing perf for ${ITK_GIT_TAG} ... \n ${ITKPERFORMANCEBENCHMARK_AUX_JSON}\n"
mkdir -p ${PERF_BLD}
pushd ${PERF_BLD}

# fca883daf05ac62ee0449513dbd2ad30ff9591f0 is sha1 that introduces itk::BuildInformation
# so all ancestors need to prevent the benchmarking from using
pushd ${ITK_SRC}
NO_ITKBUILDINFORMATION=$(git merge-base --is-ancestor HEAD fca883daf05ac62ee0449513dbd2ad30ff9591f0)
popd
if [[ ${NO_ITKBUILDINFORMATION} -eq 0 ]]; then
  ITK_HAS_INFORMATION_H="OFF"
else
  ITK_HAS_INFORMATION_H="ON"
fi

cmake -DCMAKE_BUILD_TYPE:STRING=Release \
      -DCMAKE_CXX_STANDARD:STRING=11 \
      -DITK_DIR:PATH=${ITK_BLD} \
      -DITK_HAS_INFORMATION_H:BOOL=${ITK_HAS_INFORMATION_H} \
      \
      ${PERF_SRC} > PERF_CONFIG_logger 2>&1
make -j ${logicalCpuCount} > PERF_BUILD_logger 2>&1 && ( pushd ${PERF_BLD}; ctest; popd )
# || echo "FAILED TO BUILD PERFORMANCE BENCHMARKS: ${ITK_GIT_TAG}" && exit -1
echo "Done with performance testing"
popd
